// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/phub/device.proto

package phub

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	ava "vinesai/internel/ava"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// request params.
type TokenReq struct {
	// 客户端id
	ClientId string `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	// 客户端密钥
	ClientSecret string `protobuf:"bytes,2,opt,name=client_secret,json=clientSecret,proto3" json:"client_secret,omitempty"`
	// 授权类型:authorization_code,client_credentials
	GrantType string `protobuf:"bytes,3,opt,name=grant_type,json=grantType,proto3" json:"grant_type,omitempty"`
	// 权限，默认为空
	Scope string `protobuf:"bytes,5,opt,name=scope,proto3" json:"scope,omitempty"`
	// 通过code直接获取
	Code string `protobuf:"bytes,6,opt,name=code,proto3" json:"code,omitempty"`
	// 家庭id
	HomeId string `protobuf:"bytes,7,opt,name=home_id,json=homeId,proto3" json:"home_id,omitempty"`
}

func (m *TokenReq) Reset()         { *m = TokenReq{} }
func (m *TokenReq) String() string { return proto.CompactTextString(m) }
func (*TokenReq) ProtoMessage()    {}
func (*TokenReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{0}
}
func (m *TokenReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenReq.Merge(m, src)
}
func (m *TokenReq) XXX_Size() int {
	return m.Size()
}
func (m *TokenReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenReq.DiscardUnknown(m)
}

var xxx_messageInfo_TokenReq proto.InternalMessageInfo

func (m *TokenReq) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *TokenReq) GetClientSecret() string {
	if m != nil {
		return m.ClientSecret
	}
	return ""
}

func (m *TokenReq) GetGrantType() string {
	if m != nil {
		return m.GrantType
	}
	return ""
}

func (m *TokenReq) GetScope() string {
	if m != nil {
		return m.Scope
	}
	return ""
}

func (m *TokenReq) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *TokenReq) GetHomeId() string {
	if m != nil {
		return m.HomeId
	}
	return ""
}

type TokenData struct {
	AccessToken string `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
	// string refresh_token = 2;
	ExpiresIn int64  `protobuf:"varint,3,opt,name=expires_in,json=expiresIn,proto3" json:"expires_in,omitempty"`
	TokenType string `protobuf:"bytes,4,opt,name=token_type,json=tokenType,proto3" json:"token_type,omitempty"`
}

func (m *TokenData) Reset()         { *m = TokenData{} }
func (m *TokenData) String() string { return proto.CompactTextString(m) }
func (*TokenData) ProtoMessage()    {}
func (*TokenData) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{1}
}
func (m *TokenData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenData.Merge(m, src)
}
func (m *TokenData) XXX_Size() int {
	return m.Size()
}
func (m *TokenData) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenData.DiscardUnknown(m)
}

var xxx_messageInfo_TokenData proto.InternalMessageInfo

func (m *TokenData) GetAccessToken() string {
	if m != nil {
		return m.AccessToken
	}
	return ""
}

func (m *TokenData) GetExpiresIn() int64 {
	if m != nil {
		return m.ExpiresIn
	}
	return 0
}

func (m *TokenData) GetTokenType() string {
	if m != nil {
		return m.TokenType
	}
	return ""
}

type CommonData struct {
	Code int32  `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg  string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *CommonData) Reset()         { *m = CommonData{} }
func (m *CommonData) String() string { return proto.CompactTextString(m) }
func (*CommonData) ProtoMessage()    {}
func (*CommonData) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{2}
}
func (m *CommonData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonData.Merge(m, src)
}
func (m *CommonData) XXX_Size() int {
	return m.Size()
}
func (m *CommonData) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonData.DiscardUnknown(m)
}

var xxx_messageInfo_CommonData proto.InternalMessageInfo

func (m *CommonData) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *CommonData) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// response content.
type TokenRsp struct {
	Code int32      `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg  string     `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Data *TokenData `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *TokenRsp) Reset()         { *m = TokenRsp{} }
func (m *TokenRsp) String() string { return proto.CompactTextString(m) }
func (*TokenRsp) ProtoMessage()    {}
func (*TokenRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{3}
}
func (m *TokenRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenRsp.Merge(m, src)
}
func (m *TokenRsp) XXX_Size() int {
	return m.Size()
}
func (m *TokenRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenRsp.DiscardUnknown(m)
}

var xxx_messageInfo_TokenRsp proto.InternalMessageInfo

func (m *TokenRsp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *TokenRsp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *TokenRsp) GetData() *TokenData {
	if m != nil {
		return m.Data
	}
	return nil
}

type ControlPutFileReq struct {
	FileName string `protobuf:"bytes,1,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	FileSize int64  `protobuf:"varint,2,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
	Extra    string `protobuf:"bytes,3,opt,name=extra,proto3" json:"extra,omitempty"`
	Body     []byte `protobuf:"bytes,4,opt,name=body,proto3" json:"body,omitempty"`
}

func (m *ControlPutFileReq) Reset()         { *m = ControlPutFileReq{} }
func (m *ControlPutFileReq) String() string { return proto.CompactTextString(m) }
func (*ControlPutFileReq) ProtoMessage()    {}
func (*ControlPutFileReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{4}
}
func (m *ControlPutFileReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ControlPutFileReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ControlPutFileReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ControlPutFileReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControlPutFileReq.Merge(m, src)
}
func (m *ControlPutFileReq) XXX_Size() int {
	return m.Size()
}
func (m *ControlPutFileReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ControlPutFileReq.DiscardUnknown(m)
}

var xxx_messageInfo_ControlPutFileReq proto.InternalMessageInfo

func (m *ControlPutFileReq) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *ControlPutFileReq) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *ControlPutFileReq) GetExtra() string {
	if m != nil {
		return m.Extra
	}
	return ""
}

func (m *ControlPutFileReq) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

type ControlPutFileRsp struct {
	Code uint32              `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg  string              `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Data *ControlDevicesData `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *ControlPutFileRsp) Reset()         { *m = ControlPutFileRsp{} }
func (m *ControlPutFileRsp) String() string { return proto.CompactTextString(m) }
func (*ControlPutFileRsp) ProtoMessage()    {}
func (*ControlPutFileRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{5}
}
func (m *ControlPutFileRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ControlPutFileRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ControlPutFileRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ControlPutFileRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControlPutFileRsp.Merge(m, src)
}
func (m *ControlPutFileRsp) XXX_Size() int {
	return m.Size()
}
func (m *ControlPutFileRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ControlPutFileRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ControlPutFileRsp proto.InternalMessageInfo

func (m *ControlPutFileRsp) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ControlPutFileRsp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ControlPutFileRsp) GetData() *ControlDevicesData {
	if m != nil {
		return m.Data
	}
	return nil
}

type DevicesData struct {
	DeviceId   string        `protobuf:"bytes,1,opt,name=deviceId,proto3" json:"deviceId,omitempty"`
	DeviceName string        `protobuf:"bytes,2,opt,name=deviceName,proto3" json:"deviceName,omitempty"`
	Status     *DeviceStatus `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *DevicesData) Reset()         { *m = DevicesData{} }
func (m *DevicesData) String() string { return proto.CompactTextString(m) }
func (*DevicesData) ProtoMessage()    {}
func (*DevicesData) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{6}
}
func (m *DevicesData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DevicesData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DevicesData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DevicesData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DevicesData.Merge(m, src)
}
func (m *DevicesData) XXX_Size() int {
	return m.Size()
}
func (m *DevicesData) XXX_DiscardUnknown() {
	xxx_messageInfo_DevicesData.DiscardUnknown(m)
}

var xxx_messageInfo_DevicesData proto.InternalMessageInfo

func (m *DevicesData) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *DevicesData) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func (m *DevicesData) GetStatus() *DeviceStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type DeviceStatus struct {
	Power            string `protobuf:"bytes,1,opt,name=power,proto3" json:"power,omitempty"`
	Brightness       int32  `protobuf:"varint,2,opt,name=brightness,proto3" json:"brightness,omitempty"`
	Color            string `protobuf:"bytes,3,opt,name=color,proto3" json:"color,omitempty"`
	ColorTemperature string `protobuf:"bytes,4,opt,name=colorTemperature,proto3" json:"colorTemperature,omitempty"`
}

func (m *DeviceStatus) Reset()         { *m = DeviceStatus{} }
func (m *DeviceStatus) String() string { return proto.CompactTextString(m) }
func (*DeviceStatus) ProtoMessage()    {}
func (*DeviceStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{7}
}
func (m *DeviceStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceStatus.Merge(m, src)
}
func (m *DeviceStatus) XXX_Size() int {
	return m.Size()
}
func (m *DeviceStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceStatus.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceStatus proto.InternalMessageInfo

func (m *DeviceStatus) GetPower() string {
	if m != nil {
		return m.Power
	}
	return ""
}

func (m *DeviceStatus) GetBrightness() int32 {
	if m != nil {
		return m.Brightness
	}
	return 0
}

func (m *DeviceStatus) GetColor() string {
	if m != nil {
		return m.Color
	}
	return ""
}

func (m *DeviceStatus) GetColorTemperature() string {
	if m != nil {
		return m.ColorTemperature
	}
	return ""
}

type SyncHomeInfoReq struct {
	Devices []*DevicesData `protobuf:"bytes,1,rep,name=devices,proto3" json:"devices,omitempty"`
}

func (m *SyncHomeInfoReq) Reset()         { *m = SyncHomeInfoReq{} }
func (m *SyncHomeInfoReq) String() string { return proto.CompactTextString(m) }
func (*SyncHomeInfoReq) ProtoMessage()    {}
func (*SyncHomeInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{8}
}
func (m *SyncHomeInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncHomeInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncHomeInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncHomeInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncHomeInfoReq.Merge(m, src)
}
func (m *SyncHomeInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *SyncHomeInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncHomeInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_SyncHomeInfoReq proto.InternalMessageInfo

func (m *SyncHomeInfoReq) GetDevices() []*DevicesData {
	if m != nil {
		return m.Devices
	}
	return nil
}

type SyncHomeInfoRsp struct {
	Code int32  `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg  string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *SyncHomeInfoRsp) Reset()         { *m = SyncHomeInfoRsp{} }
func (m *SyncHomeInfoRsp) String() string { return proto.CompactTextString(m) }
func (*SyncHomeInfoRsp) ProtoMessage()    {}
func (*SyncHomeInfoRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{9}
}
func (m *SyncHomeInfoRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncHomeInfoRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncHomeInfoRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncHomeInfoRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncHomeInfoRsp.Merge(m, src)
}
func (m *SyncHomeInfoRsp) XXX_Size() int {
	return m.Size()
}
func (m *SyncHomeInfoRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncHomeInfoRsp.DiscardUnknown(m)
}

var xxx_messageInfo_SyncHomeInfoRsp proto.InternalMessageInfo

func (m *SyncHomeInfoRsp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *SyncHomeInfoRsp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type ControlFileReq struct {
	HomeId   string `protobuf:"bytes,1,opt,name=homeId,proto3" json:"homeId,omitempty"`
	TraceId  string `protobuf:"bytes,2,opt,name=traceId,proto3" json:"traceId,omitempty"`
	FileName string `protobuf:"bytes,3,opt,name=fileName,proto3" json:"fileName,omitempty"`
	FileSize int64  `protobuf:"varint,4,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
	Body     []byte `protobuf:"bytes,5,opt,name=body,proto3" json:"body,omitempty"`
}

func (m *ControlFileReq) Reset()         { *m = ControlFileReq{} }
func (m *ControlFileReq) String() string { return proto.CompactTextString(m) }
func (*ControlFileReq) ProtoMessage()    {}
func (*ControlFileReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{10}
}
func (m *ControlFileReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ControlFileReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ControlFileReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ControlFileReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControlFileReq.Merge(m, src)
}
func (m *ControlFileReq) XXX_Size() int {
	return m.Size()
}
func (m *ControlFileReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ControlFileReq.DiscardUnknown(m)
}

var xxx_messageInfo_ControlFileReq proto.InternalMessageInfo

func (m *ControlFileReq) GetHomeId() string {
	if m != nil {
		return m.HomeId
	}
	return ""
}

func (m *ControlFileReq) GetTraceId() string {
	if m != nil {
		return m.TraceId
	}
	return ""
}

func (m *ControlFileReq) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *ControlFileReq) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *ControlFileReq) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

type ControlFileRsp struct {
	Code uint32              `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg  string              `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Data *ControlDevicesData `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *ControlFileRsp) Reset()         { *m = ControlFileRsp{} }
func (m *ControlFileRsp) String() string { return proto.CompactTextString(m) }
func (*ControlFileRsp) ProtoMessage()    {}
func (*ControlFileRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{11}
}
func (m *ControlFileRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ControlFileRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ControlFileRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ControlFileRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControlFileRsp.Merge(m, src)
}
func (m *ControlFileRsp) XXX_Size() int {
	return m.Size()
}
func (m *ControlFileRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ControlFileRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ControlFileRsp proto.InternalMessageInfo

func (m *ControlFileRsp) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ControlFileRsp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ControlFileRsp) GetData() *ControlDevicesData {
	if m != nil {
		return m.Data
	}
	return nil
}

type ControlWordReq struct {
	HomeId  string `protobuf:"bytes,1,opt,name=HomeId,proto3" json:"HomeId,omitempty"`
	TraceId string `protobuf:"bytes,2,opt,name=traceId,proto3" json:"traceId,omitempty"`
	Message string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *ControlWordReq) Reset()         { *m = ControlWordReq{} }
func (m *ControlWordReq) String() string { return proto.CompactTextString(m) }
func (*ControlWordReq) ProtoMessage()    {}
func (*ControlWordReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{12}
}
func (m *ControlWordReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ControlWordReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ControlWordReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ControlWordReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControlWordReq.Merge(m, src)
}
func (m *ControlWordReq) XXX_Size() int {
	return m.Size()
}
func (m *ControlWordReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ControlWordReq.DiscardUnknown(m)
}

var xxx_messageInfo_ControlWordReq proto.InternalMessageInfo

func (m *ControlWordReq) GetHomeId() string {
	if m != nil {
		return m.HomeId
	}
	return ""
}

func (m *ControlWordReq) GetTraceId() string {
	if m != nil {
		return m.TraceId
	}
	return ""
}

func (m *ControlWordReq) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type ControlWordRsp struct {
	Code uint32              `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg  string              `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Data *ControlDevicesData `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *ControlWordRsp) Reset()         { *m = ControlWordRsp{} }
func (m *ControlWordRsp) String() string { return proto.CompactTextString(m) }
func (*ControlWordRsp) ProtoMessage()    {}
func (*ControlWordRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{13}
}
func (m *ControlWordRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ControlWordRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ControlWordRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ControlWordRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControlWordRsp.Merge(m, src)
}
func (m *ControlWordRsp) XXX_Size() int {
	return m.Size()
}
func (m *ControlWordRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ControlWordRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ControlWordRsp proto.InternalMessageInfo

func (m *ControlWordRsp) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ControlWordRsp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ControlWordRsp) GetData() *ControlDevicesData {
	if m != nil {
		return m.Data
	}
	return nil
}

type ControlDevicesData struct {
	// 机器人语音提示内容
	Tip string `protobuf:"bytes,1,opt,name=tip,proto3" json:"tip,omitempty"`
	// 截取需要内容
	Exp string `protobuf:"bytes,2,opt,name=exp,proto3" json:"exp,omitempty"`
	// chatgpt返回内容
	Resp string `protobuf:"bytes,3,opt,name=resp,proto3" json:"resp,omitempty"`
}

func (m *ControlDevicesData) Reset()         { *m = ControlDevicesData{} }
func (m *ControlDevicesData) String() string { return proto.CompactTextString(m) }
func (*ControlDevicesData) ProtoMessage()    {}
func (*ControlDevicesData) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{14}
}
func (m *ControlDevicesData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ControlDevicesData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ControlDevicesData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ControlDevicesData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControlDevicesData.Merge(m, src)
}
func (m *ControlDevicesData) XXX_Size() int {
	return m.Size()
}
func (m *ControlDevicesData) XXX_DiscardUnknown() {
	xxx_messageInfo_ControlDevicesData.DiscardUnknown(m)
}

var xxx_messageInfo_ControlDevicesData proto.InternalMessageInfo

func (m *ControlDevicesData) GetTip() string {
	if m != nil {
		return m.Tip
	}
	return ""
}

func (m *ControlDevicesData) GetExp() string {
	if m != nil {
		return m.Exp
	}
	return ""
}

func (m *ControlDevicesData) GetResp() string {
	if m != nil {
		return m.Resp
	}
	return ""
}

type ControlDevicesRsp struct {
	Code int32               `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg  string              `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Data *ControlDevicesData `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *ControlDevicesRsp) Reset()         { *m = ControlDevicesRsp{} }
func (m *ControlDevicesRsp) String() string { return proto.CompactTextString(m) }
func (*ControlDevicesRsp) ProtoMessage()    {}
func (*ControlDevicesRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{15}
}
func (m *ControlDevicesRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ControlDevicesRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ControlDevicesRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ControlDevicesRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControlDevicesRsp.Merge(m, src)
}
func (m *ControlDevicesRsp) XXX_Size() int {
	return m.Size()
}
func (m *ControlDevicesRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ControlDevicesRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ControlDevicesRsp proto.InternalMessageInfo

func (m *ControlDevicesRsp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ControlDevicesRsp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ControlDevicesRsp) GetData() *ControlDevicesData {
	if m != nil {
		return m.Data
	}
	return nil
}

type DevicesStatusReq struct {
	DeviceId string        `protobuf:"bytes,1,opt,name=deviceId,proto3" json:"deviceId,omitempty"`
	Status   *DeviceStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *DevicesStatusReq) Reset()         { *m = DevicesStatusReq{} }
func (m *DevicesStatusReq) String() string { return proto.CompactTextString(m) }
func (*DevicesStatusReq) ProtoMessage()    {}
func (*DevicesStatusReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{16}
}
func (m *DevicesStatusReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DevicesStatusReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DevicesStatusReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DevicesStatusReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DevicesStatusReq.Merge(m, src)
}
func (m *DevicesStatusReq) XXX_Size() int {
	return m.Size()
}
func (m *DevicesStatusReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DevicesStatusReq.DiscardUnknown(m)
}

var xxx_messageInfo_DevicesStatusReq proto.InternalMessageInfo

func (m *DevicesStatusReq) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *DevicesStatusReq) GetStatus() *DeviceStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type DeviceAttributes struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *DeviceAttributes) Reset()         { *m = DeviceAttributes{} }
func (m *DeviceAttributes) String() string { return proto.CompactTextString(m) }
func (*DeviceAttributes) ProtoMessage()    {}
func (*DeviceAttributes) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{17}
}
func (m *DeviceAttributes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceAttributes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceAttributes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceAttributes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceAttributes.Merge(m, src)
}
func (m *DeviceAttributes) XXX_Size() int {
	return m.Size()
}
func (m *DeviceAttributes) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceAttributes.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceAttributes proto.InternalMessageInfo

func (m *DeviceAttributes) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DeviceAttributes) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type DevicesStatusData struct {
	DeviceId         string              `protobuf:"bytes,1,opt,name=deviceId,proto3" json:"deviceId,omitempty"`
	DeviceAttributes []*DeviceAttributes `protobuf:"bytes,2,rep,name=deviceAttributes,proto3" json:"deviceAttributes,omitempty"`
}

func (m *DevicesStatusData) Reset()         { *m = DevicesStatusData{} }
func (m *DevicesStatusData) String() string { return proto.CompactTextString(m) }
func (*DevicesStatusData) ProtoMessage()    {}
func (*DevicesStatusData) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{18}
}
func (m *DevicesStatusData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DevicesStatusData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DevicesStatusData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DevicesStatusData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DevicesStatusData.Merge(m, src)
}
func (m *DevicesStatusData) XXX_Size() int {
	return m.Size()
}
func (m *DevicesStatusData) XXX_DiscardUnknown() {
	xxx_messageInfo_DevicesStatusData.DiscardUnknown(m)
}

var xxx_messageInfo_DevicesStatusData proto.InternalMessageInfo

func (m *DevicesStatusData) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *DevicesStatusData) GetDeviceAttributes() []*DeviceAttributes {
	if m != nil {
		return m.DeviceAttributes
	}
	return nil
}

type DevicesStatusRsp struct {
	Code    int32                `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg     string               `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Devices []*DevicesStatusData `protobuf:"bytes,4,rep,name=devices,proto3" json:"devices,omitempty"`
}

func (m *DevicesStatusRsp) Reset()         { *m = DevicesStatusRsp{} }
func (m *DevicesStatusRsp) String() string { return proto.CompactTextString(m) }
func (*DevicesStatusRsp) ProtoMessage()    {}
func (*DevicesStatusRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{19}
}
func (m *DevicesStatusRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DevicesStatusRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DevicesStatusRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DevicesStatusRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DevicesStatusRsp.Merge(m, src)
}
func (m *DevicesStatusRsp) XXX_Size() int {
	return m.Size()
}
func (m *DevicesStatusRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_DevicesStatusRsp.DiscardUnknown(m)
}

var xxx_messageInfo_DevicesStatusRsp proto.InternalMessageInfo

func (m *DevicesStatusRsp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *DevicesStatusRsp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *DevicesStatusRsp) GetDevices() []*DevicesStatusData {
	if m != nil {
		return m.Devices
	}
	return nil
}

type DeviceAttributesData struct {
	DeviceId string `protobuf:"bytes,1,opt,name=deviceId,proto3" json:"deviceId,omitempty"`
	Name     string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Value    string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *DeviceAttributesData) Reset()         { *m = DeviceAttributesData{} }
func (m *DeviceAttributesData) String() string { return proto.CompactTextString(m) }
func (*DeviceAttributesData) ProtoMessage()    {}
func (*DeviceAttributesData) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{20}
}
func (m *DeviceAttributesData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceAttributesData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceAttributesData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceAttributesData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceAttributesData.Merge(m, src)
}
func (m *DeviceAttributesData) XXX_Size() int {
	return m.Size()
}
func (m *DeviceAttributesData) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceAttributesData.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceAttributesData proto.InternalMessageInfo

func (m *DeviceAttributesData) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *DeviceAttributesData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DeviceAttributesData) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type ExecuteAndReportCommand struct {
	Type  string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *ExecuteAndReportCommand) Reset()         { *m = ExecuteAndReportCommand{} }
func (m *ExecuteAndReportCommand) String() string { return proto.CompactTextString(m) }
func (*ExecuteAndReportCommand) ProtoMessage()    {}
func (*ExecuteAndReportCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{21}
}
func (m *ExecuteAndReportCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteAndReportCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteAndReportCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteAndReportCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteAndReportCommand.Merge(m, src)
}
func (m *ExecuteAndReportCommand) XXX_Size() int {
	return m.Size()
}
func (m *ExecuteAndReportCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteAndReportCommand.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteAndReportCommand proto.InternalMessageInfo

func (m *ExecuteAndReportCommand) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ExecuteAndReportCommand) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type ReportDeviceAttributesReq struct {
	DeviceId string                     `protobuf:"bytes,1,opt,name=deviceId,proto3" json:"deviceId,omitempty"`
	Commands []*ExecuteAndReportCommand `protobuf:"bytes,2,rep,name=commands,proto3" json:"commands,omitempty"`
}

func (m *ReportDeviceAttributesReq) Reset()         { *m = ReportDeviceAttributesReq{} }
func (m *ReportDeviceAttributesReq) String() string { return proto.CompactTextString(m) }
func (*ReportDeviceAttributesReq) ProtoMessage()    {}
func (*ReportDeviceAttributesReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{22}
}
func (m *ReportDeviceAttributesReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportDeviceAttributesReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportDeviceAttributesReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportDeviceAttributesReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportDeviceAttributesReq.Merge(m, src)
}
func (m *ReportDeviceAttributesReq) XXX_Size() int {
	return m.Size()
}
func (m *ReportDeviceAttributesReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportDeviceAttributesReq.DiscardUnknown(m)
}

var xxx_messageInfo_ReportDeviceAttributesReq proto.InternalMessageInfo

func (m *ReportDeviceAttributesReq) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *ReportDeviceAttributesReq) GetCommands() []*ExecuteAndReportCommand {
	if m != nil {
		return m.Commands
	}
	return nil
}

type ReportDeviceAttributesData struct {
	DeviceId string        `protobuf:"bytes,1,opt,name=deviceId,proto3" json:"deviceId,omitempty"`
	Status   *DeviceStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *ReportDeviceAttributesData) Reset()         { *m = ReportDeviceAttributesData{} }
func (m *ReportDeviceAttributesData) String() string { return proto.CompactTextString(m) }
func (*ReportDeviceAttributesData) ProtoMessage()    {}
func (*ReportDeviceAttributesData) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{23}
}
func (m *ReportDeviceAttributesData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportDeviceAttributesData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportDeviceAttributesData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportDeviceAttributesData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportDeviceAttributesData.Merge(m, src)
}
func (m *ReportDeviceAttributesData) XXX_Size() int {
	return m.Size()
}
func (m *ReportDeviceAttributesData) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportDeviceAttributesData.DiscardUnknown(m)
}

var xxx_messageInfo_ReportDeviceAttributesData proto.InternalMessageInfo

func (m *ReportDeviceAttributesData) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *ReportDeviceAttributesData) GetStatus() *DeviceStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type ReportDeviceAttributesRsp struct {
	Code int32                         `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg  string                        `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Data []*ReportDeviceAttributesData `protobuf:"bytes,3,rep,name=data,proto3" json:"data,omitempty"`
}

func (m *ReportDeviceAttributesRsp) Reset()         { *m = ReportDeviceAttributesRsp{} }
func (m *ReportDeviceAttributesRsp) String() string { return proto.CompactTextString(m) }
func (*ReportDeviceAttributesRsp) ProtoMessage()    {}
func (*ReportDeviceAttributesRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc372f058e4a4fb9, []int{24}
}
func (m *ReportDeviceAttributesRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportDeviceAttributesRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportDeviceAttributesRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportDeviceAttributesRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportDeviceAttributesRsp.Merge(m, src)
}
func (m *ReportDeviceAttributesRsp) XXX_Size() int {
	return m.Size()
}
func (m *ReportDeviceAttributesRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportDeviceAttributesRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ReportDeviceAttributesRsp proto.InternalMessageInfo

func (m *ReportDeviceAttributesRsp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ReportDeviceAttributesRsp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ReportDeviceAttributesRsp) GetData() []*ReportDeviceAttributesData {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterType((*TokenReq)(nil), "phub.TokenReq")
	proto.RegisterType((*TokenData)(nil), "phub.tokenData")
	proto.RegisterType((*CommonData)(nil), "phub.commonData")
	proto.RegisterType((*TokenRsp)(nil), "phub.TokenRsp")
	proto.RegisterType((*ControlPutFileReq)(nil), "phub.ControlPutFileReq")
	proto.RegisterType((*ControlPutFileRsp)(nil), "phub.ControlPutFileRsp")
	proto.RegisterType((*DevicesData)(nil), "phub.devicesData")
	proto.RegisterType((*DeviceStatus)(nil), "phub.deviceStatus")
	proto.RegisterType((*SyncHomeInfoReq)(nil), "phub.SyncHomeInfoReq")
	proto.RegisterType((*SyncHomeInfoRsp)(nil), "phub.SyncHomeInfoRsp")
	proto.RegisterType((*ControlFileReq)(nil), "phub.ControlFileReq")
	proto.RegisterType((*ControlFileRsp)(nil), "phub.ControlFileRsp")
	proto.RegisterType((*ControlWordReq)(nil), "phub.ControlWordReq")
	proto.RegisterType((*ControlWordRsp)(nil), "phub.ControlWordRsp")
	proto.RegisterType((*ControlDevicesData)(nil), "phub.controlDevicesData")
	proto.RegisterType((*ControlDevicesRsp)(nil), "phub.ControlDevicesRsp")
	proto.RegisterType((*DevicesStatusReq)(nil), "phub.DevicesStatusReq")
	proto.RegisterType((*DeviceAttributes)(nil), "phub.deviceAttributes")
	proto.RegisterType((*DevicesStatusData)(nil), "phub.devicesStatusData")
	proto.RegisterType((*DevicesStatusRsp)(nil), "phub.DevicesStatusRsp")
	proto.RegisterType((*DeviceAttributesData)(nil), "phub.deviceAttributesData")
	proto.RegisterType((*ExecuteAndReportCommand)(nil), "phub.executeAndReportCommand")
	proto.RegisterType((*ReportDeviceAttributesReq)(nil), "phub.ReportDeviceAttributesReq")
	proto.RegisterType((*ReportDeviceAttributesData)(nil), "phub.reportDeviceAttributesData")
	proto.RegisterType((*ReportDeviceAttributesRsp)(nil), "phub.ReportDeviceAttributesRsp")
}

func init() { proto.RegisterFile("proto/phub/device.proto", fileDescriptor_cc372f058e4a4fb9) }

var fileDescriptor_cc372f058e4a4fb9 = []byte{
	// 1011 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0x5f, 0x6f, 0x1b, 0x45,
	0x10, 0xcf, 0xc5, 0xb1, 0x1d, 0x4f, 0xd2, 0xd6, 0x59, 0x45, 0xf1, 0x71, 0xa8, 0x26, 0x5c, 0x5f,
	0x42, 0x41, 0x29, 0x18, 0x24, 0x84, 0x84, 0x90, 0xda, 0x84, 0x2a, 0xa9, 0x10, 0x54, 0x97, 0x00,
	0x12, 0xaa, 0x64, 0x9d, 0xef, 0xb6, 0xce, 0xa9, 0xbe, 0xdb, 0xeb, 0xee, 0x5e, 0xe3, 0xf4, 0x03,
	0xf0, 0x88, 0x10, 0x1f, 0x84, 0xcf, 0xc1, 0x63, 0x1f, 0x79, 0x44, 0xc9, 0x17, 0x41, 0x3b, 0xbb,
	0x6b, 0x9f, 0xff, 0xd5, 0xee, 0x43, 0xdf, 0x76, 0x7e, 0xb3, 0x3b, 0xf3, 0xfb, 0xcd, 0xcc, 0xee,
	0x1d, 0xb4, 0x72, 0xce, 0x24, 0x7b, 0x90, 0x5f, 0x14, 0xbd, 0x07, 0x31, 0x7d, 0x95, 0x44, 0xf4,
	0x10, 0x11, 0xb2, 0xa1, 0x20, 0xff, 0x6f, 0x07, 0x36, 0xcf, 0xd9, 0x0b, 0x9a, 0x05, 0xf4, 0x25,
	0xf9, 0x10, 0x1a, 0xd1, 0x20, 0xa1, 0x99, 0xec, 0x26, 0xb1, 0xeb, 0xec, 0x3b, 0x07, 0x8d, 0x60,
	0x53, 0x03, 0xa7, 0x31, 0xb9, 0x07, 0xb7, 0x8c, 0x53, 0xd0, 0x88, 0x53, 0xe9, 0xae, 0xe3, 0x86,
	0x6d, 0x0d, 0x9e, 0x21, 0x46, 0xee, 0x02, 0xf4, 0x79, 0x98, 0xc9, 0xae, 0xbc, 0xca, 0xa9, 0x5b,
	0xc1, 0x1d, 0x0d, 0x44, 0xce, 0xaf, 0x72, 0x4a, 0x76, 0xa1, 0x2a, 0x22, 0x96, 0x53, 0xb7, 0x8a,
	0x1e, 0x6d, 0x10, 0x02, 0x1b, 0x11, 0x8b, 0xa9, 0x5b, 0x43, 0x10, 0xd7, 0xa4, 0x05, 0xf5, 0x0b,
	0x96, 0x52, 0x45, 0xa4, 0x8e, 0x70, 0x4d, 0x99, 0xa7, 0xb1, 0x3f, 0x80, 0x86, 0x54, 0x7c, 0x8f,
	0x43, 0x19, 0x92, 0x8f, 0x61, 0x3b, 0x8c, 0x22, 0x2a, 0x44, 0x17, 0x31, 0xc3, 0x79, 0x4b, 0x63,
	0x28, 0x4b, 0x31, 0xa2, 0xc3, 0x3c, 0xe1, 0x54, 0x74, 0x93, 0x0c, 0x19, 0x55, 0x82, 0x86, 0x41,
	0x4e, 0xd1, 0x8d, 0x47, 0x35, 0xe1, 0x0d, 0x4d, 0x18, 0x11, 0x45, 0xd8, 0xef, 0x00, 0x44, 0x2c,
	0x4d, 0x99, 0x4e, 0x67, 0x89, 0xaa, 0x34, 0x55, 0x43, 0xb4, 0x09, 0x95, 0x54, 0xf4, 0x4d, 0x31,
	0xd4, 0xd2, 0xff, 0xd9, 0x56, 0x54, 0xe4, 0xab, 0x9d, 0x20, 0xf7, 0x60, 0x23, 0x0e, 0x65, 0x88,
	0xec, 0xb6, 0x3a, 0x77, 0x0e, 0x55, 0x67, 0x0e, 0x47, 0x2a, 0x03, 0x74, 0xfa, 0x97, 0xb0, 0x73,
	0xc4, 0x32, 0xc9, 0xd9, 0xe0, 0x69, 0x21, 0x1f, 0x27, 0x03, 0x6a, 0x3a, 0xf6, 0x3c, 0x19, 0xd0,
	0x6e, 0x16, 0xa6, 0xd4, 0x76, 0x4c, 0x01, 0x3f, 0x86, 0x29, 0x1d, 0x39, 0x45, 0xf2, 0x9a, 0x62,
	0xba, 0x8a, 0x76, 0x9e, 0x25, 0xaf, 0xb1, 0x15, 0x74, 0x28, 0x79, 0x68, 0x9a, 0xa4, 0x0d, 0xc5,
	0xb7, 0xc7, 0xe2, 0x2b, 0x2c, 0xc4, 0x76, 0x80, 0x6b, 0xbf, 0x3f, 0x93, 0x78, 0x4a, 0xd8, 0xad,
	0x85, 0xc2, 0x3e, 0x9b, 0x10, 0xe6, 0x6a, 0x61, 0x91, 0x0e, 0x76, 0x8c, 0xc3, 0x28, 0x4a, 0x0a,
	0x0b, 0xd8, 0x8a, 0xc7, 0x20, 0xf1, 0x60, 0x53, 0x9b, 0xa7, 0xa3, 0x61, 0xb4, 0x36, 0x69, 0x03,
	0xe8, 0xb5, 0x12, 0x6a, 0x32, 0x96, 0x10, 0x72, 0x1f, 0x6a, 0x42, 0x86, 0xb2, 0x10, 0x26, 0x35,
	0xd1, 0xa9, 0xf5, 0x8e, 0x33, 0xf4, 0x04, 0x66, 0x87, 0xff, 0xbb, 0x03, 0xdb, 0x65, 0x87, 0x2a,
	0x4d, 0xce, 0x2e, 0x29, 0x37, 0x59, 0xb5, 0xa1, 0x52, 0xf6, 0x78, 0xd2, 0xbf, 0x90, 0x19, 0x15,
	0x02, 0x53, 0x56, 0x83, 0x12, 0xa2, 0x4e, 0x45, 0x6c, 0xc0, 0xb8, 0x2d, 0x28, 0x1a, 0xe4, 0x3e,
	0x34, 0x71, 0x71, 0x4e, 0xd3, 0x9c, 0xf2, 0x50, 0x16, 0xdc, 0x4e, 0xd9, 0x0c, 0xee, 0x7f, 0x07,
	0x77, 0xce, 0xae, 0xb2, 0xe8, 0x44, 0x0d, 0x7a, 0xf6, 0x9c, 0xa9, 0xfe, 0x7e, 0x0a, 0x75, 0x53,
	0x12, 0xd7, 0xd9, 0xaf, 0x1c, 0x6c, 0x75, 0x76, 0xca, 0x42, 0x74, 0xf1, 0xec, 0x0e, 0xff, 0xeb,
	0xa9, 0xf3, 0xab, 0xce, 0x9f, 0xff, 0x87, 0x03, 0xb7, 0x4d, 0x8b, 0xed, 0x60, 0xed, 0x81, 0xb9,
	0x70, 0xa6, 0x08, 0xc6, 0x22, 0x2e, 0xd4, 0x25, 0x0f, 0xb1, 0x27, 0x3a, 0x80, 0x35, 0x55, 0xbb,
	0xec, 0xe4, 0x99, 0x12, 0x8c, 0x27, 0xd1, 0xf8, 0xd4, 0xe0, 0xa1, 0xfa, 0xf2, 0x20, 0xda, 0x91,
	0xab, 0x96, 0x46, 0x2e, 0x9e, 0xe4, 0xf3, 0x9e, 0xe6, 0xed, 0xd9, 0x28, 0xcb, 0xaf, 0x8c, 0xc7,
	0x46, 0xf5, 0xc9, 0x84, 0xea, 0x93, 0x65, 0xaa, 0x5d, 0xa8, 0xa7, 0x54, 0x88, 0xb0, 0x6f, 0x45,
	0x5b, 0xb3, 0xa4, 0x01, 0xa3, 0xbf, 0x27, 0x0d, 0x3f, 0x00, 0x99, 0xf5, 0xa9, 0xa8, 0x32, 0xc9,
	0x8d, 0x08, 0xb5, 0x54, 0x08, 0x1d, 0xe6, 0x36, 0x0f, 0x1d, 0x22, 0x1b, 0x4e, 0x45, 0x6e, 0x68,
	0xe3, 0xba, 0x74, 0xd5, 0x4d, 0xb4, 0xd5, 0xdf, 0xb0, 0x77, 0xa3, 0xfd, 0x1b, 0x34, 0x0d, 0x68,
	0x2e, 0x23, 0x7d, 0xf9, 0xd6, 0xfb, 0x3e, 0xbe, 0xcf, 0xeb, 0x4b, 0xef, 0xf3, 0xb7, 0xd0, 0xd4,
	0xf8, 0x43, 0x29, 0x79, 0xd2, 0x2b, 0x24, 0x15, 0x4a, 0x43, 0xe9, 0x89, 0xc4, 0xb5, 0xba, 0xb0,
	0xaf, 0xc2, 0x41, 0x61, 0x9f, 0x0f, 0x6d, 0xf8, 0x02, 0x76, 0xe2, 0x32, 0xb3, 0xa5, 0x4f, 0xd1,
	0xa3, 0xd9, 0x74, 0xee, 0x3a, 0xde, 0xd5, 0xbd, 0x32, 0xc9, 0xb1, 0x37, 0x98, 0xd9, 0xef, 0xbf,
	0x98, 0x2e, 0xc7, 0xca, 0x65, 0xff, 0x62, 0xfc, 0x40, 0x6c, 0x60, 0xd2, 0xd6, 0xc4, 0x03, 0x31,
	0xd6, 0x30, 0x7e, 0x26, 0x9e, 0xc1, 0xee, 0x34, 0x81, 0xa5, 0x22, 0x6d, 0xfd, 0xd6, 0xe7, 0xd5,
	0xaf, 0x52, 0xae, 0xdf, 0x11, 0xb4, 0xe8, 0x90, 0x46, 0x85, 0xa4, 0x0f, 0xb3, 0x38, 0xa0, 0x39,
	0xe3, 0xf2, 0x88, 0xa5, 0x69, 0x98, 0x61, 0x10, 0xfc, 0xca, 0x9a, 0x26, 0x48, 0xf3, 0x47, 0x30,
	0xa7, 0x09, 0x1c, 0x3e, 0xd0, 0x47, 0x8f, 0xa7, 0x6b, 0xb7, 0x64, 0x4e, 0xbe, 0x81, 0xcd, 0x48,
	0x67, 0xb3, 0x4d, 0xb8, 0xab, 0xeb, 0xb1, 0x80, 0x53, 0x30, 0xda, 0xee, 0xc7, 0xe0, 0xf1, 0xb9,
	0x39, 0x97, 0x16, 0xe7, 0x5d, 0x86, 0xf3, 0x72, 0xa1, 0xb2, 0x95, 0x5b, 0xfe, 0xd5, 0xe8, 0xa6,
	0x29, 0x7d, 0xfb, 0x3a, 0xd9, 0x62, 0xea, 0xfa, 0xc6, 0x75, 0x3a, 0x50, 0xfd, 0x29, 0x2c, 0xe4,
	0x05, 0xf9, 0x04, 0xaa, 0xfa, 0xcf, 0xe8, 0xb6, 0x3e, 0x69, 0xff, 0xfe, 0xbc, 0x09, 0x5b, 0xe4,
	0xfe, 0x5a, 0xe7, 0xaf, 0x0a, 0xd4, 0x74, 0x48, 0xf2, 0x18, 0x48, 0x99, 0xb7, 0xf9, 0x52, 0x9a,
	0x09, 0x9f, 0xbe, 0xca, 0xde, 0x5c, 0x5c, 0x85, 0x24, 0x4f, 0x60, 0xef, 0x9c, 0x87, 0x99, 0x48,
	0x13, 0x69, 0x5e, 0x1a, 0x3b, 0x1d, 0xbb, 0xfa, 0xcc, 0xe4, 0x77, 0xc8, 0x9b, 0x83, 0xaa, 0x38,
	0x07, 0xce, 0xe7, 0x0e, 0x79, 0x02, 0xde, 0xfc, 0x58, 0xea, 0xc1, 0x9d, 0x8a, 0x67, 0x5e, 0x78,
	0x6f, 0x0e, 0x8a, 0xbc, 0x9e, 0x2e, 0x8a, 0xa5, 0x52, 0x92, 0xd6, 0xc4, 0xa9, 0xf1, 0xff, 0x97,
	0x37, 0xdf, 0x81, 0x11, 0x7f, 0x81, 0xe6, 0xf7, 0x53, 0x43, 0x47, 0x3e, 0xd2, 0xdb, 0x17, 0xce,
	0xb6, 0xf7, 0xf6, 0x0d, 0x2a, 0xee, 0x23, 0xf7, 0x9f, 0xeb, 0xb6, 0xf3, 0xe6, 0xba, 0xed, 0xfc,
	0x77, 0xdd, 0x76, 0xfe, 0xbc, 0x69, 0xaf, 0xbd, 0xb9, 0x69, 0xaf, 0xfd, 0x7b, 0xd3, 0x5e, 0xeb,
	0xd5, 0xf0, 0xc7, 0xfe, 0xcb, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0x6a, 0x86, 0x51, 0x30, 0xf3,
	0x0b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ ava.Service

// This is a compile-time assertion to ensure that this generated file
// is compatible with the ava package it is being compiled against.
const _ = ava.SupportPackageIsVersion1

type OauthClient interface {
	// 获取token
	Token(c *ava.Context, req *TokenReq, opts ...ava.InvokeOptions) (*TokenRsp, error)
}

type oauthClient struct {
	c *ava.Client
}

func NewOauthClient() OauthClient {
	return &oauthClient{c: ava.AvaClient()}
}

func (cc *oauthClient) Token(c *ava.Context, req *TokenReq, opts ...ava.InvokeOptions) (*TokenRsp, error) {
	rsp := &TokenRsp{}
	err := cc.c.InvokeRR(c, "/oauth/token", req, rsp, opts...)
	return rsp, err
}

// OauthServer is the server API for Oauth ava.
type OauthServer interface {
	// 获取token
	Token(c *ava.Context, req *TokenReq, rsp *TokenRsp)
}

func RegisterOauthServer(h OauthServer) {
	var r = &oauthHandler{h: h}
	ava.AvaServer().RegisterHandler("/"+ava.AvaServer().Name()+"/oauth/token", r.Token)
}

type oauthHandler struct {
	h OauthServer
}

func (r *oauthHandler) Token(c *ava.Context, req *ava.Packet, interrupt ava.Interceptor) (rsp proto.Message, err error) {
	var in TokenReq
	err = c.Codec().Decode(req.Bytes(), &in)
	if err != nil {
		c.Errorf("server decode packet err=%v |method=%s |data=%s", err, c.Metadata.Method(), req.String())
		return nil, err
	}
	var out = TokenRsp{}
	if interrupt == nil {
		r.h.Token(c, &in, &out)
		return &out, err
	}
	f := func(c *ava.Context, req proto.Message) proto.Message {
		r.h.Token(c, req.(*TokenReq), &out)
		return &out
	}
	return interrupt(c, &in, f)
}

type DeviceClient interface {
	// 设备状态改变上报
	ReportDeviceStatus(c *ava.Context, req *DevicesStatusReq, opts ...ava.InvokeOptions) (*DevicesStatusRsp, error)
	// 设备控制控制指令透传-wav文件
	TransmitControlCommand(c *ava.Context, req chan *ControlFileReq, opts ...ava.InvokeOptions) chan *ControlFileRsp
	// 设备控制控制指令透传-文本
	TransmitControlCommandWord(c *ava.Context, req *ControlWordReq, opts ...ava.InvokeOptions) (*ControlWordRsp, error)
	// 设备控制控制指令透传-wav文件-put请求
	TransmitControlCommandFile(c *ava.Context, req *ControlPutFileReq, opts ...ava.InvokeOptions) (*ControlPutFileRsp, error)
	// 设备执行指令并上报结果状态
	ExecuteAndReport(c *ava.Context, req *ReportDeviceAttributesReq, opts ...ava.InvokeOptions) (*ReportDeviceAttributesRsp, error)
}

type deviceClient struct {
	c *ava.Client
}

func NewDeviceClient() DeviceClient {
	return &deviceClient{c: ava.AvaClient()}
}

func (cc *deviceClient) ReportDeviceStatus(c *ava.Context, req *DevicesStatusReq, opts ...ava.InvokeOptions) (*DevicesStatusRsp, error) {
	rsp := &DevicesStatusRsp{}
	err := cc.c.InvokeRR(c, "/device/reportdevicestatus", req, rsp, opts...)
	return rsp, err
}

func (cc *deviceClient) TransmitControlCommand(c *ava.Context, req chan *ControlFileReq, opts ...ava.InvokeOptions) chan *ControlFileRsp {
	var in = make(chan []byte, cap(req))
	data := cc.c.InvokeRC(c, "/device/transmitcontrolcommand", in, opts...)
	if data == nil {
		return nil
	}

	go func() {
		for b := range req {
			v, err := c.Codec().Encode(b)
			if err != nil {
				c.Errorf("client encode pakcet err=%v |method=%s |data=%s", err, c.Metadata.Method(), b.String())
				continue
			}
			in <- v
		}
		close(in)
	}()

	var rsp = make(chan *ControlFileRsp, cap(data))
	go func() {
		for b := range data {
			v := &ControlFileRsp{}
			err := c.Codec().Decode(b, v)
			if err != nil {
				c.Errorf("client decode pakcet err=%v |method=%s |data=%s", err, c.Metadata.Method(), string(b))
				continue
			}
			rsp <- v
		}
		close(rsp)
	}()
	return rsp
}

func (cc *deviceClient) TransmitControlCommandWord(c *ava.Context, req *ControlWordReq, opts ...ava.InvokeOptions) (*ControlWordRsp, error) {
	rsp := &ControlWordRsp{}
	err := cc.c.InvokeRR(c, "/device/transmitcontrolcommandword", req, rsp, opts...)
	return rsp, err
}

func (cc *deviceClient) TransmitControlCommandFile(c *ava.Context, req *ControlPutFileReq, opts ...ava.InvokeOptions) (*ControlPutFileRsp, error) {
	rsp := &ControlPutFileRsp{}
	err := cc.c.InvokeRR(c, "/device/transmitcontrolcommandfile", req, rsp, opts...)
	return rsp, err
}

func (cc *deviceClient) ExecuteAndReport(c *ava.Context, req *ReportDeviceAttributesReq, opts ...ava.InvokeOptions) (*ReportDeviceAttributesRsp, error) {
	rsp := &ReportDeviceAttributesRsp{}
	err := cc.c.InvokeRR(c, "/device/executeandreport", req, rsp, opts...)
	return rsp, err
}

// DeviceServer is the server API for Device ava.
type DeviceServer interface {
	// 设备状态改变上报
	ReportDeviceStatus(c *ava.Context, req *DevicesStatusReq, rsp *DevicesStatusRsp)
	// 设备控制控制指令透传-wav文件
	TransmitControlCommand(c *ava.Context, req chan *ControlFileReq, exit chan struct{}) chan *ControlFileRsp
	// 设备控制控制指令透传-文本
	TransmitControlCommandWord(c *ava.Context, req *ControlWordReq, rsp *ControlWordRsp)
	// 设备控制控制指令透传-wav文件-put请求
	TransmitControlCommandFile(c *ava.Context, req *ControlPutFileReq, rsp *ControlPutFileRsp)
	// 设备执行指令并上报结果状态
	ExecuteAndReport(c *ava.Context, req *ReportDeviceAttributesReq, rsp *ReportDeviceAttributesRsp)
}

func RegisterDeviceServer(h DeviceServer) {
	var r = &deviceHandler{h: h}
	ava.AvaServer().RegisterHandler("/"+ava.AvaServer().Name()+"/device/reportdevicestatus", r.ReportDeviceStatus)
	ava.AvaServer().RegisterChannelHandler("/"+ava.AvaServer().Name()+"/device/transmitcontrolcommand", r.TransmitControlCommand)
	ava.AvaServer().RegisterHandler("/"+ava.AvaServer().Name()+"/device/transmitcontrolcommandword", r.TransmitControlCommandWord)
	ava.AvaServer().RegisterHandler("/"+ava.AvaServer().Name()+"/device/transmitcontrolcommandfile", r.TransmitControlCommandFile)
	ava.AvaServer().RegisterHandler("/"+ava.AvaServer().Name()+"/device/executeandreport", r.ExecuteAndReport)
}

type deviceHandler struct {
	h DeviceServer
}

func (r *deviceHandler) ReportDeviceStatus(c *ava.Context, req *ava.Packet, interrupt ava.Interceptor) (rsp proto.Message, err error) {
	var in DevicesStatusReq
	err = c.Codec().Decode(req.Bytes(), &in)
	if err != nil {
		c.Errorf("server decode packet err=%v |method=%s |data=%s", err, c.Metadata.Method(), req.String())
		return nil, err
	}
	var out = DevicesStatusRsp{}
	if interrupt == nil {
		r.h.ReportDeviceStatus(c, &in, &out)
		return &out, err
	}
	f := func(c *ava.Context, req proto.Message) proto.Message {
		r.h.ReportDeviceStatus(c, req.(*DevicesStatusReq), &out)
		return &out
	}
	return interrupt(c, &in, f)
}

func (r *deviceHandler) TransmitControlCommand(c *ava.Context, req chan *ava.Packet, exit chan struct{}) chan proto.Message {
	var in = make(chan *ControlFileReq, cap(req))
	out := r.h.TransmitControlCommand(c, in, exit)
	if out == nil {
		return nil
	}

	go func() {
		for b := range req {
			var v = &ControlFileReq{}
			err := c.Codec().Decode(b.Bytes(), v)
			if err != nil {
				c.Errorf("server decode packet err=%v |method=%s |data=%s", err, c.Metadata.Method(), b.String())
				continue
			}
			in <- v
			ava.Recycle(b)
		}
		close(in)
	}()
	var rsp = make(chan proto.Message, cap(out))

	go func() {
		for d := range out {
			rsp <- d
		}
		close(rsp)
	}()
	return rsp
}

func (r *deviceHandler) TransmitControlCommandWord(c *ava.Context, req *ava.Packet, interrupt ava.Interceptor) (rsp proto.Message, err error) {
	var in ControlWordReq
	err = c.Codec().Decode(req.Bytes(), &in)
	if err != nil {
		c.Errorf("server decode packet err=%v |method=%s |data=%s", err, c.Metadata.Method(), req.String())
		return nil, err
	}
	var out = ControlWordRsp{}
	if interrupt == nil {
		r.h.TransmitControlCommandWord(c, &in, &out)
		return &out, err
	}
	f := func(c *ava.Context, req proto.Message) proto.Message {
		r.h.TransmitControlCommandWord(c, req.(*ControlWordReq), &out)
		return &out
	}
	return interrupt(c, &in, f)
}

func (r *deviceHandler) TransmitControlCommandFile(c *ava.Context, req *ava.Packet, interrupt ava.Interceptor) (rsp proto.Message, err error) {
	var in ControlPutFileReq
	err = c.Codec().Decode(req.Bytes(), &in)
	if err != nil {
		c.Errorf("server decode packet err=%v |method=%s |data=%s", err, c.Metadata.Method(), req.String())
		return nil, err
	}
	var out = ControlPutFileRsp{}
	if interrupt == nil {
		r.h.TransmitControlCommandFile(c, &in, &out)
		return &out, err
	}
	f := func(c *ava.Context, req proto.Message) proto.Message {
		r.h.TransmitControlCommandFile(c, req.(*ControlPutFileReq), &out)
		return &out
	}
	return interrupt(c, &in, f)
}

func (r *deviceHandler) ExecuteAndReport(c *ava.Context, req *ava.Packet, interrupt ava.Interceptor) (rsp proto.Message, err error) {
	var in ReportDeviceAttributesReq
	err = c.Codec().Decode(req.Bytes(), &in)
	if err != nil {
		c.Errorf("server decode packet err=%v |method=%s |data=%s", err, c.Metadata.Method(), req.String())
		return nil, err
	}
	var out = ReportDeviceAttributesRsp{}
	if interrupt == nil {
		r.h.ExecuteAndReport(c, &in, &out)
		return &out, err
	}
	f := func(c *ava.Context, req proto.Message) proto.Message {
		r.h.ExecuteAndReport(c, req.(*ReportDeviceAttributesReq), &out)
		return &out
	}
	return interrupt(c, &in, f)
}

func (m *TokenReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HomeId) > 0 {
		i -= len(m.HomeId)
		copy(dAtA[i:], m.HomeId)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.HomeId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Scope) > 0 {
		i -= len(m.Scope)
		copy(dAtA[i:], m.Scope)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Scope)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.GrantType) > 0 {
		i -= len(m.GrantType)
		copy(dAtA[i:], m.GrantType)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.GrantType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClientSecret) > 0 {
		i -= len(m.ClientSecret)
		copy(dAtA[i:], m.ClientSecret)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.ClientSecret)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TokenData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenType) > 0 {
		i -= len(m.TokenType)
		copy(dAtA[i:], m.TokenType)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.TokenType)))
		i--
		dAtA[i] = 0x22
	}
	if m.ExpiresIn != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.ExpiresIn))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AccessToken) > 0 {
		i -= len(m.AccessToken)
		copy(dAtA[i:], m.AccessToken)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.AccessToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommonData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommonData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TokenRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ControlPutFileReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControlPutFileReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlPutFileReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Extra) > 0 {
		i -= len(m.Extra)
		copy(dAtA[i:], m.Extra)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Extra)))
		i--
		dAtA[i] = 0x1a
	}
	if m.FileSize != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x10
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ControlPutFileRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControlPutFileRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlPutFileRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DevicesData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DevicesData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DevicesData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DeviceName) > 0 {
		i -= len(m.DeviceName)
		copy(dAtA[i:], m.DeviceName)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.DeviceName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeviceStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ColorTemperature) > 0 {
		i -= len(m.ColorTemperature)
		copy(dAtA[i:], m.ColorTemperature)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.ColorTemperature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Color) > 0 {
		i -= len(m.Color)
		copy(dAtA[i:], m.Color)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Color)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Brightness != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.Brightness))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Power) > 0 {
		i -= len(m.Power)
		copy(dAtA[i:], m.Power)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Power)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SyncHomeInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncHomeInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncHomeInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Devices) > 0 {
		for iNdEx := len(m.Devices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Devices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDevice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SyncHomeInfoRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncHomeInfoRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncHomeInfoRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ControlFileReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControlFileReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlFileReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x2a
	}
	if m.FileSize != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x20
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TraceId) > 0 {
		i -= len(m.TraceId)
		copy(dAtA[i:], m.TraceId)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.TraceId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.HomeId) > 0 {
		i -= len(m.HomeId)
		copy(dAtA[i:], m.HomeId)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.HomeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ControlFileRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControlFileRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlFileRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ControlWordReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControlWordReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlWordReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TraceId) > 0 {
		i -= len(m.TraceId)
		copy(dAtA[i:], m.TraceId)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.TraceId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.HomeId) > 0 {
		i -= len(m.HomeId)
		copy(dAtA[i:], m.HomeId)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.HomeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ControlWordRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControlWordRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlWordRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ControlDevicesData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControlDevicesData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlDevicesData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Resp) > 0 {
		i -= len(m.Resp)
		copy(dAtA[i:], m.Resp)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Resp)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Exp) > 0 {
		i -= len(m.Exp)
		copy(dAtA[i:], m.Exp)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Exp)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Tip) > 0 {
		i -= len(m.Tip)
		copy(dAtA[i:], m.Tip)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Tip)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ControlDevicesRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControlDevicesRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlDevicesRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DevicesStatusReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DevicesStatusReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DevicesStatusReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeviceAttributes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceAttributes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceAttributes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DevicesStatusData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DevicesStatusData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DevicesStatusData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DeviceAttributes) > 0 {
		for iNdEx := len(m.DeviceAttributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DeviceAttributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDevice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DevicesStatusRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DevicesStatusRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DevicesStatusRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Devices) > 0 {
		for iNdEx := len(m.Devices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Devices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDevice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeviceAttributesData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceAttributesData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceAttributesData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteAndReportCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteAndReportCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecuteAndReportCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportDeviceAttributesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportDeviceAttributesReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportDeviceAttributesReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Commands) > 0 {
		for iNdEx := len(m.Commands) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Commands[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDevice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportDeviceAttributesData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportDeviceAttributesData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportDeviceAttributesData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportDeviceAttributesRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportDeviceAttributesRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportDeviceAttributesRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDevice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintDevice(dAtA []byte, offset int, v uint64) int {
	offset -= sovDevice(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TokenReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.ClientSecret)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.GrantType)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.Scope)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.HomeId)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *TokenData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccessToken)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.ExpiresIn != 0 {
		n += 1 + sovDevice(uint64(m.ExpiresIn))
	}
	l = len(m.TokenType)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *CommonData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovDevice(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *TokenRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovDevice(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *ControlPutFileReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovDevice(uint64(m.FileSize))
	}
	l = len(m.Extra)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *ControlPutFileRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovDevice(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DevicesData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DeviceStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Power)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Brightness != 0 {
		n += 1 + sovDevice(uint64(m.Brightness))
	}
	l = len(m.Color)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.ColorTemperature)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *SyncHomeInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 1 + l + sovDevice(uint64(l))
		}
	}
	return n
}

func (m *SyncHomeInfoRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovDevice(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *ControlFileReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HomeId)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.TraceId)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovDevice(uint64(m.FileSize))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *ControlFileRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovDevice(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *ControlWordReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HomeId)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.TraceId)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *ControlWordRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovDevice(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *ControlDevicesData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tip)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.Exp)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.Resp)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *ControlDevicesRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovDevice(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DevicesStatusReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DeviceAttributes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DevicesStatusData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if len(m.DeviceAttributes) > 0 {
		for _, e := range m.DeviceAttributes {
			l = e.Size()
			n += 1 + l + sovDevice(uint64(l))
		}
	}
	return n
}

func (m *DevicesStatusRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovDevice(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 1 + l + sovDevice(uint64(l))
		}
	}
	return n
}

func (m *DeviceAttributesData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *ExecuteAndReportCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *ReportDeviceAttributesReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if len(m.Commands) > 0 {
		for _, e := range m.Commands {
			l = e.Size()
			n += 1 + l + sovDevice(uint64(l))
		}
	}
	return n
}

func (m *ReportDeviceAttributesData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *ReportDeviceAttributesRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovDevice(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovDevice(uint64(l))
		}
	}
	return n
}

func sovDevice(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDevice(x uint64) (n int) {
	return sovDevice(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TokenReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSecret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientSecret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrantType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GrantType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scope = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HomeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: tokenData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: tokenData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresIn", wireType)
			}
			m.ExpiresIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresIn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: commonData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: commonData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &TokenData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControlPutFileReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControlPutFileReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControlPutFileReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extra", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extra = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControlPutFileRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControlPutFileRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControlPutFileRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ControlDevicesData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DevicesData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: devicesData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: devicesData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &DeviceStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: deviceStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: deviceStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Power = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Brightness", wireType)
			}
			m.Brightness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Brightness |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Color = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColorTemperature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColorTemperature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncHomeInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncHomeInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncHomeInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, &DevicesData{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncHomeInfoRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncHomeInfoRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncHomeInfoRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControlFileReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControlFileReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControlFileReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HomeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControlFileRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControlFileRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControlFileRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ControlDevicesData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControlWordReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControlWordReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControlWordReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HomeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControlWordRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControlWordRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControlWordRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ControlDevicesData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControlDevicesData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: controlDevicesData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: controlDevicesData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControlDevicesRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControlDevicesRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControlDevicesRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ControlDevicesData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DevicesStatusReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DevicesStatusReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DevicesStatusReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &DeviceStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceAttributes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: deviceAttributes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: deviceAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DevicesStatusData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: devicesStatusData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: devicesStatusData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceAttributes = append(m.DeviceAttributes, &DeviceAttributes{})
			if err := m.DeviceAttributes[len(m.DeviceAttributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DevicesStatusRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DevicesStatusRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DevicesStatusRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, &DevicesStatusData{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceAttributesData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: deviceAttributesData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: deviceAttributesData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteAndReportCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: executeAndReportCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: executeAndReportCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportDeviceAttributesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportDeviceAttributesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportDeviceAttributesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commands", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commands = append(m.Commands, &ExecuteAndReportCommand{})
			if err := m.Commands[len(m.Commands)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportDeviceAttributesData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: reportDeviceAttributesData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: reportDeviceAttributesData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &DeviceStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportDeviceAttributesRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportDeviceAttributesRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportDeviceAttributesRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &ReportDeviceAttributesData{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDevice(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDevice
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDevice
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDevice
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDevice        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDevice          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDevice = fmt.Errorf("proto: unexpected end of group")
)
