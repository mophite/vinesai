package tuya

import (
	"errors"
	"time"
	"vinesai/internel/ava"
	"vinesai/internel/lib/connector"
	"vinesai/internel/lib/connector/env"
	"vinesai/internel/x"
	"vinesai/proto/phub"

	"github.com/gogo/protobuf/proto"
	jwtv5 "github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
)

func init() {
	connector.InitWithOptions(
		env.WithApiHost("https://openapi.tuyacn.com"),
		env.WithMsgHost("pulsar://mqe.tuyacn.com:7285"),
		env.WithAccessID("55tvajraw3edkr78qqa9"),
		env.WithAccessKey("9ad81ab89b384354bf6ad3f1bb0b7e2e"),
		env.WithDebugMode(false),
	)
	// Start the service
	//go messaging.Listener()
}

var jwtKey = []byte("AOGQ6MNVIU9Y5J5LK0PWB1A8H2Z4ERCB")

type tokenClaims struct {
	Timestamp string
	Uid       string
	Phone     string
	jwtv5.RegisteredClaims
}

func parseJWToken(token string) (*tokenClaims, error) {
	t, err := jwtv5.ParseWithClaims(token, &tokenClaims{}, func(t *jwtv5.Token) (interface{}, error) {
		return jwtKey, nil
	})

	if err != nil {
		return nil, err
	}

	if claims, ok := t.Claims.(*tokenClaims); ok && t.Valid {
		return claims, nil
	}

	return nil, errors.New("invalid token")
}

var defaultExpiryDelta = time.Hour * 24 * 30 * 12 * 100

func generateJWToken(c *ava.Context, phone, uid string) string {
	expiry := jwtv5.NewNumericDate(x.LocalTimeNow().Add(defaultExpiryDelta))
	token := jwtv5.NewWithClaims(jwtv5.SigningMethodHS256, tokenClaims{
		Timestamp: x.LocalTimeNow().Format(time.RFC3339),
		Uid:       uid,
		Phone:     phone,
		RegisteredClaims: jwtv5.RegisteredClaims{
			Issuer:    "homingai",
			Subject:   uid,
			Audience:  []string{"homingai"},
			ExpiresAt: expiry,
			NotBefore: jwtv5.NewNumericDate(x.LocalTimeNow()), //token在此时间之前不能被接收处理
			IssuedAt:  jwtv5.NewNumericDate(x.LocalTimeNow()),
			ID:        uuid.New().String(),
		},
	})

	str, err := token.SignedString(jwtKey)
	if err != nil {
		c.Errorf("generateJWToken |err=%v", err)
		return ""
	}

	return str
}

var whiteHttpPathList = map[string]bool{
	"/home/tuya/login": true,
}

func Authorization(c *ava.Context) (proto.Message, error) {

	if _, ok := whiteHttpPathList[c.Metadata.Method()]; ok {
		return nil, nil
	}

	var rsp phub.CommonData
	//处理bearar
	token := c.GetHeader("Authorization")
	if token == "" {
		rsp.Code = 401
		rsp.Msg = "请求头Authorization信息缺失"
		return &rsp, errors.New("请求头Authorization信息缺失")
	}

	t, err := parseJWToken(token)
	if err != nil {
		rsp.Code = 401
		rsp.Msg = "身份认证失败"
		return &rsp, errors.New("身份认证失败")
	}

	c.Infof("Oauth |data=%v", x.MustMarshal2String(t))

	c.Set("X-Tuya-Uid", t.Uid)
	return nil, nil
}

func getTuyaUid(c *ava.Context) string {
	return c.GetString("X-Tuya-Uid")
}

// ai返回内容格式
type aiResp struct {
	Voice  string       `json:"voice"`
	Result []aiRespData `json:"result"`
}

type aiRespData struct {
	Id   string `json:"id"`
	Data struct {
		Commands []status `json:"commands"`
	} `json:"data"`
}

// 获取用户的设备列表
type deviceListResp struct {
	Result  []*device `json:"result"`
	Success bool      `json:"success"`
	T       int       `json:"t"`
	Tid     string    `json:"tid"`
}

type command struct {
	Devices   []string `json:"devices"`
	Functions []struct {
		Code   string      `json:"code"`
		Desc   string      `json:"desc"`
		Name   string      `json:"name"`
		Type   string      `json:"type"`
		Values interface{} `json:"values"`
	} `json:"functions"`
}

// 批量获取指令集
type commandsResp struct {
	Result  []*command `json:"result"`
	Success bool       `json:"success"`
	T       int        `json:"t"`
	Tid     string     `json:"tid"`
}

type shortDeviceInfo struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

type status struct {
	Code  string      `json:"code"`
	Value interface{} `json:"value"`
}

// 用户设备信息
type device struct {
	Id       string    `json:"id"`
	Name     string    `json:"name"`
	Status   []*status `json:"status"`
	Category string    `json:"category"`
	Online   bool      `json:"online"`
}

// 用户家庭信息
type AutoGenerated struct {
	Result []struct {
		GeoName string  `json:"geo_name"`
		HomeID  int     `json:"home_id"`
		Lat     float64 `json:"lat"`
		Lon     float64 `json:"lon"`
		Name    string  `json:"name"`
		Role    string  `json:"role"`
	} `json:"result"`
	Success bool   `json:"success"`
	T       int64  `json:"t"`
	Tid     string `json:"tid"`
}

// 根据ai返回的简短数据找出全量数据
func shortDeviceInfo2Devices(s []*shortDeviceInfo, l []*device) (map[string]*device, []string) {
	// 创建一个 map，键是设备 ID，值是完整的 device 结构体
	deviceMap := make(map[string]*device)

	// 将完整的设备信息存储到 map 中
	for _, d := range l {
		deviceMap[d.Id] = d
	}

	// 准备一个切片保存匹配的设备
	var result = make(map[string]*device, len(s))

	var ids = make([]string, 0, len(s))
	// 根据 shortDeviceInfo 中的 ID 找出对应的完整设备信息
	for _, shortInfo := range s {
		if fullDevice, exists := deviceMap[shortInfo.Id]; exists {
			result[shortInfo.Id] = fullDevice
			ids = append(ids, shortInfo.Id)
		}
	}

	return result, ids
}
